:mod:`arg_mine.api.session`
===========================

.. py:module:: arg_mine.api.session


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   arg_mine.api.session.ApiUrl
   arg_mine.api.session._BlockAll
   arg_mine.api.session.TimeoutHTTPAdapter



Functions
~~~~~~~~~

.. autoapisummary::

   arg_mine.api.session.get_session
   arg_mine.api.session.fetch


.. data:: _logger
   

   

.. data:: DEFAULT_TIMEOUT
   :annotation: = 200

   

.. data:: DEFAULT_POOL_SIZE
   :annotation: = 4

   

.. py:class:: ApiUrl

   Enum-like class for holding the target URLs

   .. attribute:: GATEWAY_BASE_URL
      :annotation: = https://api.argumentsearch.com/en

      

   .. attribute:: CLASSIFY_BASE_URL
      

      

   .. attribute:: CLUSTER_BASE_URL
      

      

   .. attribute:: SEARCH_BASE_URL
      

      


.. py:class:: _BlockAll

   Bases: :class:`http.cookiejar.CookiePolicy`

   Block cookies from requests query

   .. rubric:: Examples

   >>> s = requests.Session()
   >>> s.cookies.policy = _BlockAll()

   .. method:: set_ok(self, cookie, request)


      Return true if (and only if) cookie should be accepted from server.

      Currently, pre-expired cookies never get this far -- the CookieJar
      class deletes such cookies itself.



.. py:class:: TimeoutHTTPAdapter(*args, **kwargs)

   Bases: :class:`requests.adapters.HTTPAdapter`

   requests HTTPAdapter with default timeout

   .. method:: send(self, request, **kwargs)


      Sends PreparedRequest object. Returns Response object.

      :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
      :param stream: (optional) Whether to stream the request content.
      :param timeout: (optional) How long to wait for the server to send
          data before giving up, as a float, or a :ref:`(connect timeout,
          read timeout) <timeouts>` tuple.
      :type timeout: float or tuple or urllib3 Timeout object
      :param verify: (optional) Either a boolean, in which case it controls whether
          we verify the server's TLS certificate, or a string, in which case it
          must be a path to a CA bundle to use
      :param cert: (optional) Any user-provided SSL certificate to be trusted.
      :param proxies: (optional) The proxies dictionary to apply to the request.
      :rtype: requests.Response



.. function:: get_session(timeout=DEFAULT_TIMEOUT, pool_size=DEFAULT_POOL_SIZE)

   Get a requests Session object, with our target default parameters

   :param timeout: timeout in seconds for server response
   :type timeout: float
   :param pool_size: how many pool connections we allow within the session
   :type pool_size: int

   :returns:
   :rtype: requests.Session


.. function:: fetch(base_url: str, payload: dict, timeout: float = DEFAULT_TIMEOUT, request_session=None)

   Make request from base API service, with error handling

   :param base_url: The target URL for the API POST call, eg ApiUrl.CLASSIFY_BASE_URL
   :type base_url: str
   :param payload: Contains all of the associated parameters
   :type payload: dict
   :param timeout: API call timeout, in seconds
   :type timeout: float
   :param request_session: Optional, uses this session to speed up repeated API calls
   :type request_session: requests.Session

   :returns:
   :rtype: dict with the API response

   :raises errors.Unavailable: when requests returns an unknown HTTPError
   :raises errors.Refused: when server returns a 400 and "Website could not be crawled"
   :raises errors.ArgumenTextGatewayError: when server returns a 400 and unspecified message
   :raises errors.NotResponding: when connection fails or times out


